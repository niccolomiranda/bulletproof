{"history":[{"local":{"id":"b209367d-ccfc-41fa-ac91-3da87b7d4194","canvas":{},"ctx":{}},"visible":true,"locked":false,"aspectRatio":1,"isElement":true,"opacity":1,"displace":0,"trackMouse":0,"mouseMomentum":0,"blendMode":"NORMAL","bgDisplace":0,"mask":0,"maskBackground":{"type":"Vec3","_x":0,"_y":0,"_z":0},"maskAlpha":0,"dispersion":0,"axisTilt":0,"layerType":"image","imageLoaded":false,"effects":[],"size":0.462,"rotation":0,"height":1615,"repeat":0,"fitToCanvas":false,"scaleX":1,"scaleY":1,"src":"https://assets.unicorn.studio/images/Oa14gipZJEMdF4HB6HwU3AqvWqB2/b_us.png","speed":0.5,"thumb":"https://assets.unicorn.studio/images/Oa14gipZJEMdF4HB6HwU3AqvWqB2/b_us_@thumbnail.png?authuser=0","translateX":0,"translateY":0,"width":1201,"compiledFragmentShaders":["#version 300 es\nprecision mediump float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uBgTexture; uniform sampler2D uTexture; uniform vec2 uMousePos; uniform int uSampleBg;out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.00);uv = uv - pos;vec4 color = texture(uTexture, uv); vec4 background = vec4(0);if(uSampleBg == 1) { background = texture(uBgTexture, vTextureCoord); }color = mix(background, color/(color.a + 0.00000001), color.a * 1.00);fragColor = color; }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix; uniform vec2 uMousePos;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { float angleX = uMousePos.y * 0.5 - 0.25; float angleY = (1.-uMousePos.x) * 0.5 - 0.25; mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angleX), -sin(angleX), 0.0, 0.0, sin(angleX), cos(angleX), 0.0, 0.0, 0.0, 0.0, 1.0); mat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angleY), 0.0, cos(angleY), 0.0, 0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY; gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz; vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"]},{"visible":true,"aspectRatio":1,"layerType":"effect","type":"mouse","texture":false,"animating":true,"mouseMomentum":0,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uTexture; uniform sampler2D uPingPongTexture; uniform vec2 uResolution;const float PI = 3.1415926; const float ITERATIONS = 24.0; const float kernel[24] = float[]( 0.7978845608028654, 0.795118932516684, 0.7868794322038799, 0.7733362336056986, 0.7547664553859864, 0.7315447328280048, 0.704130653528599, 0.6730536454899063, 0.6388960110447045, 0.6022748643096089, 0.5638237508206051, 0.5241747061566029, 0.48394144903828673, 0.443704309411472, 0.40399737110811773, 0.36529817077804383, 0.3280201493519873, 0.29250790855907144, 0.2590351913317835, 0.2278053882403838, 0.19895427758549736, 0.17255463765302306, 0.1486223271179862, 0.12712341303392466 );out vec4 fragColor;vec4 permute(vec4 t) { return t * (t * 34.0 + 133.0); } vec3 grad(float hash) { vec3 cube = mod(floor(hash / vec3(1.0, 2.0, 4.0)), 2.0) * 2.0 - 1.0; vec3 cuboct = cube; cuboct[int(hash / 16.0)] = 0.0; float type = mod(floor(hash / 8.0), 2.0); vec3 rhomb = (1.0 - type) * cube + type * (cuboct + cross(cube, cuboct)); vec3 grad = cuboct * 1.22474487139 + rhomb; grad *= (1.0 - 0.042942436724648037 * type) * 3.5946317686139184; return grad; } vec4 bccNoiseDerivativesPart(vec3 X) { vec3 b = floor(X); vec4 i4 = vec4(X - b, 2.5); vec3 v1 = b + floor(dot(i4, vec4(.25))); vec3 v2 = b + vec3(1, 0, 0) + vec3(-1, 1, 1) * floor(dot(i4, vec4(-.25, .25, .25, .35))); vec3 v3 = b + vec3(0, 1, 0) + vec3(1, -1, 1) * floor(dot(i4, vec4(.25, -.25, .25, .35))); vec3 v4 = b + vec3(0, 0, 1) + vec3(1, 1, -1) * floor(dot(i4, vec4(.25, .25, -.25, .35))); vec4 hashes = permute(mod(vec4(v1.x, v2.x, v3.x, v4.x), 289.0)); hashes = permute(mod(hashes + vec4(v1.y, v2.y, v3.y, v4.y), 289.0)); hashes = mod(permute(mod(hashes + vec4(v1.z, v2.z, v3.z, v4.z), 289.0)), 48.0); vec3 d1 = X - v1; vec3 d2 = X - v2; vec3 d3 = X - v3; vec3 d4 = X - v4; vec4 a = max(0.75 - vec4(dot(d1, d1), dot(d2, d2), dot(d3, d3), dot(d4, d4)), 0.0); vec4 aa = a * a; vec4 aaaa = aa * aa; vec3 g1 = grad(hashes.x); vec3 g2 = grad(hashes.y); vec3 g3 = grad(hashes.z); vec3 g4 = grad(hashes.w); vec4 extrapolations = vec4(dot(d1, g1), dot(d2, g2), dot(d3, g3), dot(d4, g4)); vec3 derivative = -8.0 * mat4x3(d1, d2, d3, d4) * (aa * a * extrapolations) + mat4x3(g1, g2, g3, g4) * aaaa; return vec4(derivative, dot(aaaa, extrapolations)); } vec4 bccNoiseDerivatives_XYBeforeZ(vec3 X) { mat3 orthonormalMap = mat3( 0.788675134594813, -0.211324865405187, -0.577350269189626, -0.211324865405187, 0.788675134594813, -0.577350269189626, 0.577350269189626, 0.577350269189626, 0.577350269189626); X = orthonormalMap * X; vec4 result = bccNoiseDerivativesPart(X) + bccNoiseDerivativesPart(X + 144.5); return vec4(result.xyz * orthonormalMap, result.w); }vec2 random2(vec2 p) { return fract(sin(vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)))) * 43758.5453); }vec3 rgb2hsv(vec3 c) { vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0); vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g)); vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));float d = q.x - min(q.w, q.y); float e = 1.0e-10; return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x); }vec3 chromatic_aberration(vec3 color, vec2 uv, vec2 offset) { vec4 left = texture(uTexture, uv - offset); vec4 right = texture(uTexture, uv + offset);color.r = left.r; color.b = right.b;return color; }vec2 pixelate(vec2 uv) { float aspectRatio = uResolution.x / uResolution.y; float scale = 0.62 / 2.0; vec2 modulate = mod(vec2(uv.x * aspectRatio, uv.y) - 0.5, (scale + 0.01) / 12.0); return vec2( uv.x - modulate.x / aspectRatio + (0.08333 * scale) / 2.0, uv.y - modulate.y + (0.08333 * scale) / 2.0 ); }vec2 angleToDir(float angle) { float rad = angle * 2.0 * PI; return vec2(cos(rad), sin(rad)); }vec4 blurTrail(vec2 uv, vec2 mouseDir) { vec2 distorted = mouseDir * 0.4; float total_weight = 0.0; vec4 color = vec4(0);for (int i = 0; i <= 24; i++) { float scale = 0.0001 + 0.62 * 0.5; float weight = kernel[i]; vec2 offset = distorted * (1.5 + scale) * mix(1.0, float(i) / ITERATIONS, scale); vec4 samp = texture(uTexture, uv - offset); samp.rgb = chromatic_aberration(samp.rgb, uv - offset, offset * 0.25 * 0.12); color += weight * samp; total_weight += weight; } return color / total_weight; }vec4 noiseTrail(vec2 uv, vec2 mouseDir, float strength, float aspectRatio) { vec4 color = vec4(0); vec2 noise = bccNoiseDerivatives_XYBeforeZ(vec3((uv * vec2(aspectRatio, 1) - mouseDir / 8.0 - 0.5) * 250.0 * 0.62, strength)).xy * strength * 0.25; vec2 distorted = (mouseDir + noise) * 0.4; color = texture(uTexture, uv - distorted); color.rgb = chromatic_aberration(color.rgb, uv - distorted, distorted * 0.25 * 0.12); return color; }vec4 pixelTrail(vec2 uv, vec2 mouseDir, float strength) { vec4 color = vec4(0); vec2 distorted = mouseDir * 0.4; vec2 pixelated = uv - distorted; color = texture(uTexture, pixelated); color.rgb = chromatic_aberration(color.rgb, pixelated, distorted * 0.25 * 0.12); return color; }vec4 revealTrail(vec2 uv, vec2 mouseDir, float strength) { vec4 color = vec4(0); float zMix = strength; vec2 distorted = mouseDir * 0.4 * 0.62; color = texture(uTexture, uv - distorted); color.rgb = chromatic_aberration(color.rgb, uv - distorted, distorted * 0.25 * 0.12); color = mix(vec4(vec3(0, 0, 0), 1.00), color, zMix); return color; }vec4 inverTrail(vec2 uv, vec2 mouseDir, float strength) { vec4 color = vec4(0); vec2 distorted = mouseDir * 0.4 * 0.62; float sMix = step(0.3, strength); color = texture(uTexture, uv - distorted); color.rgb = chromatic_aberration(color.rgb, uv - distorted, distorted * 0.25 * 0.12); color.rgb = mix(color.rgb, 1.0 - color.rgb, sMix); return color; }vec4 defaultTrail(vec2 uv, vec2 mouseDir) { vec4 color = vec4(0); vec2 distorted = mouseDir * 0.4; color = texture(uTexture, uv - distorted); color.rgb = chromatic_aberration(color.rgb, uv - distorted, distorted * 0.25 * 0.12); return color; }vec4 shatterTrail(vec2 uv, vec2 mouseDir, float strength, float aspectRatio) { vec2 st = uv * vec2(aspectRatio, 1) * 80.0 * 0.62; vec2 i_st = floor(st); vec2 f_st = fract(st);float m_dist = 15.0; vec2 m_point; vec2 d;for (int j = -1; j <= 1; j++) { for (int i = -1; i <= 1; i++) { vec2 neighbor = vec2(float(i), float(j)); vec2 point = random2(i_st + neighbor);vec2 diff = neighbor + point - f_st; float dist = length(diff);if (dist < m_dist) { m_dist = dist; m_point = point; d = diff; } } }vec2 distorted = mouseDir * 0.4; vec2 offset = (m_point * 0.2 * 1.0 * 2.0) - (1.0 * 0.2) - distorted; return texture(uTexture, uv + offset * strength); }vec4 getTrailColor(vec2 uv, vec2 mouseDir, float strength) { vec4 color = vec4(0); float aspectRatio = uResolution.x / uResolution.y;switch (3) { case 1: return blurTrail(uv, mouseDir); case 2: return noiseTrail(uv, mouseDir, strength, aspectRatio); case 3: return pixelTrail(uv, mouseDir, strength); case 4: return revealTrail(uv, mouseDir, strength); case 5: return inverTrail(uv, mouseDir, strength); case 6: return shatterTrail(uv, mouseDir, strength, aspectRatio); default: return defaultTrail(uv, mouseDir); } }void main() { vec2 uv = vTextureCoord; vec2 pingpongUv = uv;if (3 == 3) { pingpongUv = pixelate(pingpongUv); }vec3 mouseRgb = texture(uPingPongTexture, pingpongUv).rgb; vec3 mouseTrail = rgb2hsv(mouseRgb);float angle = mouseTrail.x; float strength = mouseTrail.z * (0.26 * 2.0); vec2 direction = angleToDir(angle); vec2 mouseDir = direction * strength;vec4 color = getTrailColor(uv, mouseDir, strength);fragColor = color; }","#version 300 es\nprecision lowp float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uPingPongTexture; uniform vec2 uMousePos; uniform vec2 uPreviousMousePos; uniform vec2 uResolution; uniform float uTime;const float PI = 3.1415926; const float TWOPI = 6.2831852;out vec4 fragColor;vec3 hsv2rgb(vec3 c) { vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0); vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www); return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y); }mat2 rot(float a) { return mat2(cos(a), -sin(a), sin(a), cos(a)); }vec2 liquify(vec2 st, float angle) { float aspectRatio = uResolution.x / uResolution.y; st.x *= aspectRatio; st = st * rot(angle * TWOPI); float amplitude = 0.003; for (float i = 1.0; i <= 5.0; i++) { st = st * rot(i / 5.0 * PI * 2.0); st += vec2( amplitude * cos(i * 5.0 * st.y + uTime * 0.02), amplitude * sin(i * 5.0 * st.x + uTime * 0.02) ); } st = st * rot(-angle * TWOPI); st.x /= aspectRatio; return st; }void main() { float aspectRatio = uResolution.x / uResolution.y; vec2 uv = vTextureCoord; vec2 correctedUv = uv * vec2(aspectRatio, 1.0);vec2 dir = (uMousePos - uPreviousMousePos) * vec2(aspectRatio, 1.0); float dist = length(dir); dir = normalize(dir);float rad = 1.06 * 0.4 * mix(aspectRatio, 1.0, 0.5); float angle = atan(dir.y, dir.x); if (angle < 0.0) angle += TWOPI;if(0.17 > 0.) { uv = mix(uv, liquify(uv, smoothstep(0.0, 1.0, angle)), 0.17); }float t = clamp(dot(correctedUv - uPreviousMousePos * vec2(aspectRatio, 1.0), dir) / dist, 0.0, 1.0); vec2 closestPoint = mix(uPreviousMousePos, uMousePos, t) * vec2(aspectRatio, 1.0); float distanceToLine = distance(correctedUv, closestPoint);float s = smoothstep(rad, rad * 0.00, distanceToLine);vec3 color = vec3(angle / TWOPI, 1.0, 1.0); vec3 mouseColor = hsv2rgb(color);vec3 lastFrameColor = texture(uPingPongTexture, mix(uv, uv / 1.03 + 0.015, 0.49)).rgb; vec3 draw = mix(lastFrameColor, mouseColor, min(1.0, dist * s));fragColor = vec4(draw * pow(0.50, 0.1), 1.0); }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix;uniform sampler2D uPingPongTexture;out vec3 vVertexPosition; out vec2 vTextureCoord;vec3 rgb2hsv(vec3 c) { vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0); vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g)); vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));float d = q.x - min(q.w, q.y); float e = 1.0e-10; return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x); }const float PI = 3.1415926;void main() {vec3 vertexPosition = aVertexPosition;gl_Position = uPMatrix * uMVMatrix * vec4(vertexPosition, 1.0); vTextureCoord = aTextureCoord; }","#version 300 es\nprecision lowp float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix;out vec3 vVertexPosition; out vec2 vTextureCoord;void main() {vec3 vertexPosition = aVertexPosition;gl_Position = uPMatrix * uMVMatrix * vec4(vertexPosition, 1.0); vTextureCoord = aTextureCoord; vVertexPosition = vertexPosition; }"],"data":{"depth":false}},{"visible":true,"aspectRatio":1,"layerType":"effect","type":"texturize","speed":0.31,"texture":false,"animating":true,"mouseMomentum":0,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform float uTime;float random (in float x) { return fract(sin(x)*1e4); }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; float time = floor(uTime * 0.5) * 2.; float size = 0.54 * 0.2 * random(time + 0.001); float floorY = floor(uv.y/size); float floorX = floor(uv.x/size); float phase = 0.01 * 0.01; float phaseTime = phase + uTime; float chromab = 0.50 * 0.75; float offset = 0.;float glitchMod = max(0., sign(random(sin(floorY + offset + phase)) - 0.5 - (1. - 0.35*2.)/2.)); float offX = ( (random(floorY + offset * glitchMod + phase)) * 0.07 - 0.07/2. )/5.;uv.x = mix(uv.x, uv.x + offX * 2., glitchMod);float waveFreq = 30.0; float waveAmp = 0.005 * 0.00;float rogue = smoothstep(0., 2., sin((uv.y + 0.01) * waveFreq * (1. - 0.54) * 2. + uTime * 0.05) - 0.5) * 0.2 * 0.00; uv.x += sin(uv.y * waveFreq + uTime) * waveAmp + rogue; uv.y += sin(uv.x * waveFreq + uTime) * waveAmp; float waveX = sin(uv.y * waveFreq + uTime) * waveAmp + rogue * chromab * 0.2;vec4 color = texture(uTexture, uv); color.r = texture(uTexture, vec2(uv.x + (glitchMod * -offX * chromab - waveX), uv.y)).r; color.b = texture(uTexture, vec2(uv.x + (glitchMod * offX * chromab + waveX), uv.y)).b; fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false}}],"options":{"name":"Untitled project","fps":60,"dpi":2,"scale":1,"includeLogo":false,"isProduction":false,"freePlan":false,"version":"1.2.7"},"version":"1.2.7"}